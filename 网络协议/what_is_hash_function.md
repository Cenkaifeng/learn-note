# 哈希函数

记录一下特征，不会说是怎么实现的，因为实现 hash 的算法非常多
MD5 、 SHA-512 / SHA-224 / SHA-256 / SHA-384 等等

### 历史迭代流程

MD4—>MD5—>SHA0—>SHA1—>SHA2—>SHA3

### 特点

1. 输入域无穷大，输出域可以很大，但是有穷尽
2. 哈希函数没有任何随记的机制，固定的输入一定是固定的输出
3. 输入无穷多但输出值有限，所以不同输入也可能输出相同（哈希碰撞）
4. 离散性：再相似的不同输入，所得到的输出值，也会彻底打乱
5. 均匀性：一大群不同的输入，最终会得到的返回值呈现均匀性

哈希算法的特征
●
正向快速：无论输入的长度有多大，都能够快速计算出哈希值。比如把一个字符或者一本书的所有文字作为输入，都可以快速计算出哈希值。
●
逆向困难：通过哈希值，无法在有限时间内逆向推出输入。比如通过哈希值0x8a5e1d339fafc39350fd8cf1d7ca7982091c27f6b77f75bd4ddab3df425b4f8c，无法逆向推出输入是123.
●
输入敏感：输入的微小变化，会导致输出的显著变化。比如123和124的哈希值千差万别，看上去没有任何关联。
●
避免碰撞：很难找到两个不同的输入，使得输出的哈希值一致（即发生碰撞）。比如很难找到除123之外的另一个输入，使它的哈希值也是0x8a5e1d339fafc39350fd8cf1d7ca7982091c27f6b77f75bd4ddab3df425b4f8c。
●
不可预测：通过输入无法预测输出，所以挖矿时随机数nonce只能从1开始累加。

**离散型、随机性实质上都是一回事（都是足够乱）**·

举个例子

```js
// 假设有个hash()

const a // a 是个百万级的数

const res = hash(a);

res %= m - 1
// res 0 ~ m - 1 中每个数出现的频率是一样的。

```