## TCP 和 UDP

> 两个协议都在传输层，我们常说 TCP 是面向连接而 UDP 是面向无连接的。

* UDP 发出请求后，不考虑对方是否能收到、内容是否完整、顺序是否正确。收到数据后也不会进行通知。
* 首部结构简单，在数据传输时能实现最小的开销

ps: 直播有可能基于UDP或者TCP, 主要看看有没对丢包有强的要求

### TCP 传输控制协议 Transimision control Protocal
> **可靠、面向连接的传输协议**，传输效率低（特点：在不可靠的 IP 层上建立可靠的传输层）。TCP 提供全双工服务，即**数据可在同一时间双向传播**。

**你知道为什么IP层不可靠么？**
不能保证IP数据报能成功到达目的地，是一种尽力而为的传输服务，路由器对IP报错误处理方式是丢包，并发送ICMP给源地址。
IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。

#### 1. 数据格式

![TCP数据格式](./TCP数据格式.png)

不算可选 20个字节。1字节 = 8bit(8位)

**为什么说TCP是双工的？**

**为什么需要建立三次握手？**
简单说就是，三次握手是双方进行可靠性检验前提下最小通信次数。


http1.0 四次挥手的问题。

为了防止最终ACK 丢失，发送ACK后需要等待一段时间（TIME_WAIT ~ CLOSED） ，因为如果丢包服务器端需要重新发送FIN包，如果客户端已经closed,那么服务端会将结果解析成错误。从而在高并发非长连接的场景下会有大量端口被占用，一旦超过最大端口数（65535）就不能在创建新的端口。

所以http1.1 提出了 keep-alive 长连接复用

### UDP

特点：面向无连接、快速。
使用 UDP 发送数据时，有各种因素会导致数据包出错，虽然 UDP 可以校验数据是否正确，但是对于错误的数据包，UDP 并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。

这也就是 UDP的两个问题

* 数据包在传输过程中容易丢失；
* 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。

可以基于 udp 实现可靠的协议（http/3)，QUIC。在利用 UDP 1RTT 优势的前提下，协议内封装了 TLS、多路复用、有序交付、快速握手、可靠性。

使用UDP的应用：
  域名系统(DNS)、视频应用、IP语音(VolP)

> RTT：网络延迟（Round Trip Time）,这是一个衡量网络性能的一个重要指标。e.g. TCP 握手就需要1.5 RTT 


### 滑动窗口

- 窗口协商

* 滑动窗口(控制流量的方式)：TCP 是全双工的，所以发送端有发送缓存区；接收端有接收缓存区，要发送的数据都放到发送者的缓存区，发送窗口（要被发送的数据）就是要发送缓存中的那一部分,滑动窗口主要是用于接收方。

特点：
- 客户端有自己的缓存区，服务端也有自己的缓存区。会根据网络状况调整发送数据的多少
- 我们发送数据的时候是乱序发送的，但是当我收到某个包后，可能之前的包没有收到，此时需要等待前面序号的包到了才可以（队头阻塞：头回来了才能往后滑动）
- 服务端会和客户端说明发送数据的个数
- 如果某个数据丢包了，那需要重新发送（超时重传 RTO ,性能最差)ps: 数据包的序号就是那个seq
- 当接收方的缓存区收满了，需要每隔一段时间由发送方发出一个探测包，来询问能否调整窗口的大小。上层协议消耗掉了接收方的数据，接收方也会主动通知发送方调整窗口，继续发送数据 PSH。
- 流量控制 控制发送方的频率。



* 核心流量控制：在建立连接时，接收端会告诉发送端子机的窗口大小（rwnd),每次接收端收到数据后都会再次确认(rwnd) 大小，如果值为0，停止发送数据。（并发送窗口探测包，持续监测窗口大小）


> 滑动窗口的算法


ps: 1帧 ≈ 1500字节： ip头 20个字节 tcp 头 20个字节 = tcp `1460`字节( 一个包最大也是这个....多了会自己分开)


### 粘包

`nagle`（node内置） 算法的基本定义是**任意时刻，最多只能有一个未被确认的小段**（TCP内部控制）
> 实际用的时候会出现很小字节很碎的请求，但是由于包太小，请求太快了，所以需要下面的Cork算法

`Cork` 算法 当达到MSS(Maximum Segment Size：最大帧尺寸) 值时统一进行发送（此时就是帧的大小 - ip 头 - tcp 头 = 1460 字节）理论值

粘包就是通过Cork算法把多包粘成一个包发送

### TCP 拥塞处理 （队头阻塞：若果在非长连接的情况会有大量端口被占用）

> 举例：假设接收方窗口大小是无限的，接收到数据后发送 ACK 包，那么传输数据主要是依赖于网络带宽，带宽的大小是有限的。

* TCP 维护一个拥塞窗口 `cwnd` (congesion window) 变量，在传输过程中没有拥塞就将此值增大。如果出现拥塞（超时重传 RTO(Retransmission TimeOut) ) 就将窗口值减少

* cwnd < SSTHRESH 使用慢开始算法
* cwnd > ssthresh 使用拥塞色避免算法
* ROT 时更新 ssthresh 值为当前窗口的一般，更新cwnd = 1 
![TCP数据格式](./快重传.png)
三个TCP问题：
1. 队头阻塞
2. 慢启动，这时候出现慢启动的问题(每次重传需要慢启动...效率不高)
3. 短连接

用快重传处理因为丢包导致超时重传的慢启动。
> 快重传，可能在发送过程中出现丢包情况。此时不要立即回退到慢开始阶段，而是对已经收到的报文重复确认（通过后续接受的包的ack)，如果确认次数达到三次（ack应答3次），立即进行重传**快恢复**算法（减少超时重传机制的出现），降低重置 cwnd 的频率，cwnd 用原本的一半而不直接从 0 开始。

> 这是在 TCP Reno 版本实现的，之前的慢启动是 TCP Tahoe 版本
![TCP数据格式](./快重传2.png)
3次ack从上次缺的开始

### TCP 的一些问题/缺陷
- TCP顺序问题：后面的包先到达，需要等待前面的包返回之后才可以继续传输（队头阻塞问题）**（等窗口头部包完成传输才能往后滑动）**
- 慢启动的过程，非常消耗性能
- time-wait 客户端连接服务器最后不会立即断开，在高并发、短连接的情况下，会出现端口全被占用导致新的请求无法连入。（time-wait 指的是四次挥手断开方最后一次ACK后到CLOSED的这段时间）

由于队头阻塞的原因，有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。

**TCP 这么多问题，为什么不直接更换协议？**
1. 中间设备僵化：包括了路由器、防火墙、NAT、交换机等。它们通常依赖一些很少升级的软件，这些软件使用了大量的 TCP 特性，这些功能被设置之后就很少更新了。

2. 操作系统也是导致 TCP 协议僵化的另外一个原因：TCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。通常操作系统的更新都滞后于软件的更新，因此要想自由地更新内核中的 TCP 协议也是非常困难的。

### 小结：TCP 的控制手段、以及自身优化手段
控制手段
  1）滑动窗口控制传输速度
优化手段
  2）粘包（短连接） cork nagle
  3）拥塞处理 快重传快恢复（恢复成原来 ssthresh 的一半 TCP Reno）

