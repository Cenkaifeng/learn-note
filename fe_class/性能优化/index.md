## Js 常见性能优化

#### 常见指标

* 白屏时间：从输入 URL 开始，到页面开始有变化，只要有任何像素点变化，都算是白屏时间的完结。
* 首页时间：指当 onload 事件触发的时候，也就是整个首页加载完成的时候。
```js
function getFirstPage() {
  const firstPage = performance.timing.loadEventEnd - performance.timing.fetchStart
  console.log('FIRST_PAGE', firstPage)
}
```


1. **FP** 首次绘制
  指页面上第一个像素、色块变动
2. **FCP** 首次内容绘制
  值页面上绘制了第一个元素

> FP 与 FCP 的最大的区别就在于： FP **指的是绘制像素**，比如说页面的背景色是灰色的，那么在显示会泽背景时就记录下了 FP 指标。但是此时 DOM 内容还没开始绘制，可能需要文件下载、解析等过程，只有当 DOM 内容发生变化才会触发，比如说渲染出了一段文字，此时就会记录下 FCP 指标。因此我们可以把这两个指标认为是和白屏时间相关的指标，所以肯定是越快越好。

3. FMP 首次有效绘制
  有一定争议性，指的是页面中有效内容绘制，对于每个网站来说有效内容不同，一般不做研究。
  TODO：对应争议链接

4. **LCP** 最大内容绘制
  用于记录视窗内最大的元素绘制的时间，该时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能发生改变，另外该指标会在用户第一次交互后停止记录。

5. **TTI** 首次可交互时间
  需要满足已下条件：
    1. 从 FCP 指标后开始计算;
    2. 持续 5 秒内无长任务（执行时间超过50 ms ) 且无两个以上正在进行中的 GET 请求;
    3. 往前回溯至 5 秒前的最后一个长任务结束的时间

    通俗点说就是 FCP 完成后 5秒内没有超2个 50ms 的执行时间的任务，参考图 TODO: TTI 图片
    
    解决方式：看 long task 执行的 O(n) 时间复杂度

6. **FID**： 首次输入延迟
  记录在 FCP 和 TTI 之间用户首次与页面交互时响应的延迟


7. **CLS**: 累计位偏移量 = 位移影响面积 * 位移距离

8. TTFB

在 Chrome 的标准中，一般我们最关心的是 LCP FID CLS
#### 工具

1. `web-vitals`: 起个前端框架，不需要你单独写 new performence api 
缺点： 目前只能统计 `CLS | FCP | FID | LCP | TTFB ` . 如果需要扩充可以另写 `Performance` 进行改造。

2. Chrome Dev Tools：Lighthouse
  Lighthouse 前身是 Audits 在 Chrome 83之后是 Lighthouse。 之后有很多其他变更，例如将 FMP 从评分指标中换成其他指标。同时测试指标中会提示出需要优化的地方，已经该项指标的解读说明。
3. Page Speed
4. Jspref


#### 解决方案 TODO

1. 提高带宽
2. 工程加速
  webpack tree-shaking 剪枝
  减小js
  url-loader小图标 base64 || 图片转 font字体
3. 路由懒加载，只有在使用的时候进行路由加载
4. CDN加速
5. app cache
6. gizp: 具体说就是————客户端Gzip离线包，服务器资源Gzip压缩
8. 对于少量小图标（单个尽量不要超过10k), 我们可以用 url-loader 打包。或者使用将图标转化非字体库，异步进行加载
9. 对于大图标的话，需要做到在展示的时候再去加载。也就是当图片出现到浏览器窗口的时候再去加载，而不是首屏的图片全部加载（Chrome 本身在光栅化阶段有视口优先渲染的优化）

---

1. 图片，图片占位，图片懒加载。 雪碧图
2. 使用 prefetch / preload 预加载等新特性
3. 服务器合理设置缓存策略
4. async（加载完当前js立即执行）/defer(所有资源加载完之后执行js)
5. 减少Dom的操作，减少重排重绘
6. 从客户端层面，首屏减少和客户端交互，合并接口请求。
7. 数据缓存。	
8. 首页不加载不可视组件。
9. 防止渲染抖动，控制时序。	
10. 减少组件层级。	
11. 优先使用Flex布局。

##### CLS 优化

文档结构相同：脱离文档流 VS 不脱离文档流
  文档结构相同，脱离文档：Position
    脱离之后 CLS： 0 对原本文档流没有影响
  不脱离文档流: 使用 transform
  宽高相同
  指定图片高度

1. 如果经常需要变动的元素，脱离文档流，或者是占据位置，只是隐藏
2. 对于唯一等操作，使用动画代替
3. 在定义图片的时候，就应该给出具体的宽高


##### TTI/FID 优化


long task 开启 web work 新起线程不影响main.js


**bigPipe** 服务端渲染的优化点

`bigPipe` 是由 facebook 提出来的⼀种动态⽹⻚加载技术。它将⽹⻚分解成称为 pagelets 的⼩块，然后分块传输到浏
览器端，进⾏渲染。它可以有效地提升⾸屏渲染时间。
可以看出，bigpipe的适⽤是服务端进⾏渲染，然后将⼀块⼀块的⽂件传递给前端。
那么为什么需要分块传输呢？

继续做对照试验：
分块传输 VS 不分块传输
可以明显的看出，在不进⾏分块传输的时候，需要经过漫⻓的等待，界⾯才能看到变化。ssr渲染的宗旨就是更快
的渲染，然⽽在⻓任务时候，效果不理想。