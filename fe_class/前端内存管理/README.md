
## 平时有关注过前端的内存处理吗？

### 一. 前端的内存管理：你了解js中的内存处理吗？ 什么情况会导致内存泄漏呢？

代码空间：主要存储可执行代码

栈空间：
1. 存储原始类型
2. 执行上下文

堆空间：存储引用类型

为什么不都用栈存呢？

需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。

1. 内存的生命周期

内存分配：声明变量 函数 对象的时候
内存的使用：读写内存，使用变量 函数等
内存回收：使用完毕，由辣鸡回收机制自动回收不再使用的内存

2. js 中的内存分配

```js
const n = 123;
const s = 'sss';
```


3. js 内存使用

```js
const a = 10;
console.log(a); // 使用

```

### 二、 js中的垃圾回收机制

垃圾回收的算法主要依赖于引用的概念

1. 引用计数法

看一个对象是否有指向他的引用，如果没有其他对象指向他了，说明当前这个对象不再被需要了.

他的问题：**循环引用！！**

如果两个对象相互引用，尽管他们已不再被使用，但是引用计数无法识别，导致内存泄漏。


2. 标记清除法

将“不再使用的的对象”定义为“无法到达的对象”

从根部js的全局对象触发，定时扫描内存中的对象，凡是无法从根部到达的对象，就会被标记为不再使用，稍微进行回收

* 垃圾收集器在运行的时候会给内存中的所有变量都加上标记
* 将从根部触发能够触及到的对象标记清除
* 剩下的还有标记的变量被视为准备删除的变量
* 垃圾收集器销毁带有标记的值 回收内存空间

3. 代际假说和分代收集

* 新生代
存放的是生存时间短的对象
副垃圾回收器负责... Scavenge算法：所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域
对象晋升策略：对象区域和空闲区域翻转两次还存在的对象，升级到老生代。


* 老生代
存放的生存时间久的对象
采用 标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。

全停顿：一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。

4. 调用栈下移ESP(记录当前执行状态的指针)
当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。

5. 常见的内存泄漏

5.1 全局变量

```js

function foo() {
    bar1 = 'aaa'; // 相当于声明在window.bar1
    this.bar2 = 'aaaa'
}

foo(); // 执行函数事this指向window ,相当于一个函数给全局变量增加了两个变量
```

2. 未被清理的定时器和回调函数

setInterval
setTimeout

clearInterval
clearTimeout

3. 闭包

个人最喜欢《你不知道的js》里对闭包的描述
> 一个内部函数，有权访问包含其的外部函数的变量 —— 《你不知道的js》


```js

var theThing = null;
var replaceThing = function() {
    var originalThing =theThing;

    var unused =function() {
        if(originalThing) {
            console.log(111);
        }
    }

    theTing = {
        longStr: '111',
        method: function() {
            console.log
        }
    }    
}



setInterval(repalceThing, 1000)
```
每次调用replaceThing, theTing 得到一个包含巨大字符串和一个对于信必报method的对象

unued引用了originThing

5.3 DOM 引用

var elements= {
    image: document.getElementById('111');
}

elements.image = null;

6. 怎么避免呢？

尽量减少全局变量
使用完数据后，及时解除引用.null
避免死循环等持续执行的操作

### 实现一个sizeof 函数

接收一个对象参数，计算传入的对象所占的Bytes数