# React 大型工程约定与依赖版本管理

## 依赖管理

### 1. 当 workspace 不起作用的时候，排查那些关键点？

【回答】
    1. 引用路径格式错误
    2. npm 版本
        （npm 7.0 开始已经支持workspace了（以前大家使用的比较多的是lerna 以及yarn ）

### 2. 为什么我们更推荐 package.json 里写死版本？

【回答】

- `~` 会匹配最近的小版本依赖包，比如 ~1.2.3 会匹配所有 1.2.x 版本，但是不包括 1.3.0
- `^` 会匹配最新的大版本依赖包，比如 ^1.2.3 会匹配所有 1.x.x 的包，包括 1.3.0，但是不包括 2.0.0
- `*` 安装最新版本的依赖包，比如 *1.2.3 会匹配 x.x.x

以上灵活版本的写法，会在构建阶段出现不可预料的风险

### 3. 版本规范是什么？x.y.z 分别代表什么？

【回答】
版本号遵循 [SemVer规范](https://semver.org/)

`SemVer`规范的标准版本号采用 `X.Y.Z` 的格式，其中 X、Y 和 Z 为非负的整数，且禁止在数字前方补零。

- X 对应主版本号(`major`)：当项目中做了不兼容的 API 修改，属于大版本提升
- Y 对应次版本号(`minor`)：当你做了向下兼容的功能性新增
- Z 对应修订号(`patch`)：当你做了向下兼容的问题修正。

### 4. package-lock.json 的作用是什么？

【回答】
对整个依赖树进行版本固定的（锁死）
npm5.4.2 之后的 lockfile 和 yarn 基本可以看作是同一个东西
install 命令执行后会检测 lockfile 是否存在，不存在就生出。存在就读取配置并且和package.json中的版本范围写法做对比，然后以此拉取依赖。如果在用灵活版本写法，基本上每次npm i 都会导致lockfile文件大量变动（但是你又不能不提交）这样会存在大量的提交记录...

### 5. 为什么搭建私有源？

【回答】
依赖一致性 + 私有包管理

### 6. 一种 unit 按需引入配置

通过 `babel-plugin-import` 实现

`babel-plugin-import` 在编译阶段会把引用路径改成精确路径

等于说我所有第三方/自研工具都通过`unit`这个包进行管理，然后按需生成路径

## 2. 约定

### 1. 为什么鼓励使用 merge 而非 rebase ？

【回答】

- `rebase` 有两个隐患 - `安全性`和`可跟踪性`。如果你违反了 rebase 黄金法则，重写项目历史可能会给你的协作工作流带来灾难性的影响，而且不会有合并提交中附带的信息——你看不到 feature 分支中并入了上游的哪些更改。

- `merge` 的合并会保留分支信息，
如果全使用 `rebase` 就会让你的 commits history 变成一条光秃秃的直线。

### 2. commit msg 规范有哪些？

【回答】

见过但不限于下面几种格式
`[uperCase]: [content];` 匈牙利命名法
`[lowerCase]() [content];`

• feat，新功能（feature）
• fix，修补bug .eg 'fix: #00023 【修复问题功能模块 】 xxxxxx'
• refactor，重构
• bump，修改package.json 需跟随改动库以及对应版本号（后续工具解决）
• docs，文档
• style，格式（不影响代码运行的变动）
• test，增加测试
• chore，构建过程或辅助工具的变动
• other，其他

### 3. 当合并有冲突的时候，有什么较为稳妥的方式？

其实有一种工作模式是，本地处理开发分支。每次push 前需要先 pull 做一下冲突预处理。当然也可以在 pr 中做新旧代码比较。

### 4. 为什么采用 prettier ？

代码格式化，统一保存提交的基本格式/美观，其实也是用工程来管理人的一种体现
